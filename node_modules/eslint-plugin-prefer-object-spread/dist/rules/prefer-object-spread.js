'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var message = 'Use a spread property instead of Object.assign().';

function tail(arr) {
	return arr.slice(-1)[0];
}

function createFix(node, sourceCode) {
	function fix(fixer) {
		var args = node.arguments;

		function processArg(n, i) {
			if (n.type === 'ObjectExpression' && n.properties.length === 0) {
				return '';
			}
			var next = args[i + 1] || {};
			var currentArg = '...' + sourceCode.getText(n);
			if (next.start) {
				return currentArg + sourceCode.text.slice(n.end, next.start);
			}
			return currentArg;
		}

		var processedArgs = args.map(processArg).join('');
		var lastArg = tail(args);
		var firstArg = args[0];
		var funcEnd = sourceCode.text.slice(lastArg.end, node.end).split(')')[0];
		var funcStart = tail(sourceCode.text.slice(node.start, firstArg.start).split('('));
		return fixer.replaceText(node, '({' + funcStart + processedArgs + funcEnd + '})');
	}

	return fix;
}

exports.default = {
	meta: {
		docs: {
			description: message,
			category: 'Best Practices',
			recommended: false
		},
		fixable: 'code'
	},
	create: function create(context) {
		var cloneOnly = context.options[0] !== 'always';
		var sourceCode = context.getSourceCode();

		return {
			CallExpression: function CallExpression(node) {
				var callee = node.callee,
				    args = node.arguments;


				var isObjectAssign = callee.type === 'MemberExpression' && callee.object.name === 'Object' && callee.property.name === 'assign';

				var isCloneOperation = args.length && args[0].type === 'ObjectExpression';

				// Object spread can't be used when passing a spread element to Object.assign()
				// E.g., Object.assign(...a)
				var hasSpreadElement = args.length && args.some(function (x) {
					return x.type === 'SpreadElement';
				});

				if (isObjectAssign && !hasSpreadElement && (isCloneOperation || !cloneOnly)) {
					context.report({ node: node, message: message, fix: createFix(node, sourceCode) });
				}
			}
		};
	}
};